```{r setup, echo=FALSE}
opts_chunk$set(tidy=TRUE, echo=TRUE, highlight=TRUE, figalign='center', fig.height=9, fig.width=9, out.width='800px', message=FALSE, error=TRUE, warning=FALSE, cache=FALSE)

# Setup report details
clientname="Ali Ardestani"
clientemail="aardestani@rics.bwh.harvard.edu"
lablocation="BWH"
analystname="Oliver Hofmann"
analystemail="ohofmann@hsph.harvard.edu"
```

Array analysis for `r clientname` (`r clientemail`) at `r lablocation`. Contact `r analystname` (`r analystemail`) for additional details. Request from client was:

> We are a basic science lab interested in intestinal mechanisms of diabetes remission. We have used the human exon array (HuEx1.0 st-v2 with 6553600 probe count) to understand the differences in expression profile of diabetic vs. non-diabetic human intestine (8 patients in each arm) and hopefully to find potential targets for further study.

> The Partners HealthCare Center for Personalized Genetic Medicine Microarray Facility has helped us with array analysis and data analysis. However as I mentioned to John in the RNA-seq course last week we are interested to reproduce the results and also learn the data analysis along the way.

## Methods summary

All HuEx 1.0 arrays were processed using the 'oligo' [BioConductor package][1], quality-controlled with [arrayQualityMetrics][2] and [RMA normalized][3]. Differentially expressed genes were identified using [limma][4]. 

## Workflow

The most recent update of this html document occurred: `r date()`. The sections below provide descriptions of the included results and include code to reproduce them. 

### Bioconductor and R libraries used

```{r libraries, echo=TRUE}
library(oligo)
library(arrayQualityMetrics)
library(pd.huex.1.0.st.v2)
library(googleVis)
library(limma)
library(pheatmap)
library(RColorBrewer)
library(ggplot2)
library(biomaRt)
library(AnnotationDbi)
library(Biostrings)
library(ggdendro)

# Grab John Hutchinson's convenience functions
source("http://dl.dropboxusercontent.com/u/4253254/Resources/functions.r")
```

### Variables

Cutoffs and path information:

```{r VARIABLES, echo=TRUE}
# Setup Data and Results directory variables
baseDir <- '..'
dataDir <- file.path(baseDir, "data")
metaDir <- file.path(dataDir, "meta")
resultsDir <- file.path(baseDir, "results")
covarsfilename <- 'covdesc.txt'

# Cutoffs and filtering variables
pvalcutoff <- 0.25
logFCcutoff <- log2(1.5)
exprfilter <- 2.5

# Visualization
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", 
               "#0072B2", "#D55E00", "#CC79A7", "#000000")
```

### Load raw data

Load phenotypes and array names from metadata file; this file also contains the file names and descriptions of the CEL files:

```{r dataload, cache=TRUE}
celFiles <- list.celfiles(dataDir, full.names=TRUE)
affyRaw <- read.celfiles(celFiles, verbose=FALSE)
```

## Sample metadata

Importing the provided sample meta-data. Current workflow assumes no batch effect (i.e., all data was processed at the same time, all arrays generated by the core facility with a single run) and that samples are not paired.

```{r covars}
# Simple tab delimited file with CEL file in first column (no heading for this column) 
# and sample metadata (i.e. sampleID, treatment group, batch etc.) in 
# subsequent columns
covars <- read.delim(file.path(metaDir, covarsfilename), row.names=1) 

# Re-order by filename; expected to be the same order as the affyRaw
# samples
covars <- covars[order(row.names(covars)), ]
identical(basename(celFiles), row.names(covars)) ## sanity check
pData(affyRaw) <- covars 
validObject(affyRaw) ## sanity check
```

```{r viewMeta, results='asis'}
# Sample information table
pd <- pData(affyRaw)
pd.gvis <- gvisTable(as.data.frame(apply(pd, 2, as.character)), options=list(width=600))  
print(pd.gvis, "chart")
```

### Initial QC check

Conducted using the arrayQualityMetrics library on the _raw data_ grouped by sample type.

```{r rawQC, eval=FALSE}
arrayQualityMetrics(expressionset=affyRaw, 
                    outdir=file.path(resultsDir, 'report_raw'), 
                    force=TRUE, 
                    do.logtransform=TRUE, 
                    intgroup=c("Group", "Gender", "Race"))
```

Link to the [raw data QC report](./results/report_raw/index.html). Raw data looks okay, but overall signal intensity seems low indicating low amounts of RNA. Sample #5 seems to be an outlier, will check again after normalization. Samples do not cluster by group, almost as if there is some sort of batch effect. Are the patients all the same gender? Different age groups? Some other systematic differences?


### Background correct and normalize

The data was normalized for differential gene expression analysis using Robust Multichip Average ([RMA][5]) in the oligo BioConductor package. Here, RMA normalizes the intensity values at the probe level, and collapses probes into "core" transcripts based on annotations provided by Affymetrix:

```{r normalize, results='hide', cache=TRUE}
geneSummaries <- rma(affyRaw, target="core", background=T, normalize=T)
```

### QC after normalization

Repeats the previous QC using the normalized data:

```{r normQC, eval=FALSE}
arrayQualityMetrics(expressionset=geneSummaries, 
                    outdir=file.path(resultsDir, 'report_rma.core'), 
                    force=TRUE, 
                    do.logtransform=FALSE,
                    intgroup=c("Group", "Gender", "Race"))
```

Link to the [normalized data QC report](./results/report_rma.core/index.html). Looks okay, but sample JE16_1865E is an outlier. Groups cluster closer to each other now, but are still difficult to separate based on the first two principal components alone. Quick check of the misbehaving sample for spatial artifacts:

```{r imageCheck, cache=TRUE, eval=TRUE}
image(affyRaw, 4, col=gray((64:0)/64))
```

Nothing unusual to be seen. Dropping this array for now and re-normalizing the remaining samples:

```{r dropArrays, cache=TRUE}
affyRaw <- affyRaw[, pData(affyRaw)$Name != 'JE16_1865E']
geneSummaries <- rma(affyRaw, target="core", background=T, normalize=T)
```

The MA plots in the (normalized) quality control worry me slightly. There are _very_ few differences between each chip and the overall mean intensity distribution, indicating that the samples are all highly similar to each other.


### Basic clustering

Initial hierarchical clustering based on the euclidian distance of individual samples.

```{r clusteringDendro}
# Helper functions
plot_dendro <- function(x, title="", metadata.colname.identifier="Name", 
                        labels.colname="Label") {
  meta.x <- pData(x)
  myDist <- dist(t(exprs(x)))
  myTree <-hclust(myDist)
  dhc <- as.dendrogram(myTree)
  ddata <- dendro_data(dhc, type="rectangle")
  ddata$labels <- merge(ddata$labels, meta.x, by.x="label", by.y="Label")
  ggplot(segment(ddata)) +
    geom_segment(aes(x=x, y=y, xend=xend, yend=yend)) +
    theme_dendro() +
    geom_text(data=label(ddata), aes(x=x, y=y, label=Group, color=Group, hjust=-0.1), size=6) +
    coord_flip() + scale_y_reverse(expand=c(0.2, 50)) +
    theme(axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank()) 
}

plot_dendro(geneSummaries)
```

The dendrogram does not look particularly promising -- DM and NL samples cluster in distinctive subgroups.


### PCA

Exploring how well the sample subset separates in a PCA plot with more components:

```{r pcaTest}
# Compare the first four components
PCAplot(eset=geneSummaries, categories=c('Group'), colorpalette=cbPalette, 
        title='NL/DM PCA', numcomponents=4)

# Try again based on gender
PCAplot(eset=geneSummaries, categories=c('Gender'), colorpalette=cbPalette, 
        title='Male/Female PCA')

# Just in case, check Race as well
PCAplot(eset=geneSummaries, categories=c('Race'), colorpalette=cbPalette, 
        title='Race PCA')
```

**Principal Component Analysis Figure**
The figure shows a scatterplot of the arrays along all dual combinations of the first four principal components. Each sample group is represented by a separate color. Principal component analysis is a dimension reduction and visualisation technique that is here used to project the multivariate data vector of each array into a two-dimensional plot, such that the spatial arrangement of the points in the plot reflects the overall data (dis-) similarity between the arrays. You can use this plot to explore if the arrays cluster, and whether this is according to an intended experimental factor or according to unintended causes (e.g., batch effects). 

Samples do not separate by their group. On the plus side, gender and race do not seem to have any significant impact on the clusters, either.

### Pre-filtering

Filter out probes non "main" category probes. Now that we're done normalizing, we can get rid of the control probes (nearly 2/3 of the probes on the array). We can also use the mean expression levels to filter out probes that are poorly expressed across all samples. We're unlikely to to see significant differences for these genes and by using fewer probes in the [multiple test correction](http://en.wikipedia.org/wiki/Multiple_comparisons) of our statistical tests we increase our chances of seeing significant results.

Here I filtered out probes that show a mean intensity level (after log transformation) of less than `r exprfilter`:
  
```{r genefilter}
# Retrieve NetAffx Biological Annotation
featureData(geneSummaries) <- getNetAffx(geneSummaries, "transcript")

# Remove control and unannotated probes
geneSummaries <- geneSummaries[which(pData(featureData(geneSummaries))$category=="main"), ]
dim(geneSummaries)

# Remove probes with low expression levels; relaxed filter
means <- rowMeans(exprs(geneSummaries))
geneSummaries <- geneSummaries[which(means > exprfilter), ]
dim(geneSummaries)
```

To assess the impact of filtering, here's another look at how samples cluster followed by a PCA:

```{r postfilter}
plot_dendro(geneSummaries)
PCAplot(eset=geneSummaries, categories=c('Group'), colorpalette=cbPalette, 
        title='NL/DM PCA', numcomponents=4)
```

Both plots show slight improvements after low/noise signals are removed.

### Annotations

Parse the array feature data (i.e., information about the probes) to get the gene symbols that correspond to each probeset group on the array:

```{r features}
# Extract the 'gene assignment' annotation
annot <- pData(featureData(geneSummaries)[, c('geneassignment')])
categories <- pData(featureData(geneSummaries)[, c('category')])

# Generate a list of gene symbols and ensembl transcript ids from
# the gene assignment
desc <- annot[, 1]
symbols <- unlist(lapply(desc, function(x) strsplit(x, ' // ')[[1]][2]))

# Extract Entrez Gene Identifier
entrezIDs <- unlist(lapply(desc, function(x) {
end.index <- length(strsplit(x, " // ")[[1]])
entrezID <- strsplit(x, " // ")[[1]][end.index]
return(entrezID)
}))

# Add the original probe identifiers
probeids <- row.names(annot)

# Merge into a single annotation entry
gene.annots <- cbind(cbind(probeids, categories), cbind(symbols, entrezIDs))
gene.annots <- gene.annots[order(gene.annots[, "probeids"]), ]
gene.annots <- as.data.frame(gene.annots)
head(gene.annots)

# Check to make sure data is correct
identical(length(featureData(geneSummaries)$probesetid), length(symbols)) 
identical(as.character(gene.annots$probeids), probeids) 
head(gene.annots$symbols[!is.na(gene.annots$symbols)]) 
identical(rownames(gene.annots), rownames(exprs(geneSummaries)))
```

### Differential Expression Analyses with _limma_

A linear model for microarray data analysis (Limma) was performed on the samples to identify differentially expressed genes between pair-wise comparisons of sample groups. Limma fits a linear model to the expression data for all samples for each gene and is designed to handle complex experiments involving comparisons between many RNA targets simultaneously.

To perform limma, we constructed two matrices. The design matrix provides a representation of the different sample groups which have been analysed. The contrast matrix allows the coefficients defined by the design matrix to be combined into contrasts of interest. Each contrast corresponds to a pairwise comparison between sample groups.

#### Design matrix 

Create a matrix with arrays as rows, puberty status as column; The first coefficient measures log2-expression of each gene in the EGFP strain. The second coefficient measures the log2-fold change of SATB2 over EGFP. Adjusting for gender, but not for race:

```{r design, results='asis'}
gender <- pData(geneSummaries)$Gender
groups <- pData(geneSummaries)$Group
design <- model.matrix(~gender+groups)
colnames(design) <- c('Intercept', 'Male', 'NL_vs_DM') 

pd.gvis <- gvisTable(as.data.frame(design), options=list(width=600))  
print(pd.gvis, "chart")
```

Running the actual comparison:

```{r limma}
eset <- exprs(geneSummaries)
fit <- lmFit(eset, design)
fit2 <- eBayes(fit)
options(digits=2)
```

#### Volcanoplots

These plots help visualize relationship between fold change and signifcance of changes in expression between groups. Genes outside the two vertical orange lines show more than 2-fold changes in expression between groups; genes which pass an FDR (false discovery rate) multiple testing correction of `r pvalcutoff` (`r pvalcutoff*100`% FDR) and show at least a `r 2^logFCcutoff`-fold change in expression are colored blue. The larger the pointsize, the more likely there is significant expression change (B = log-odds of differential expression) between the sample groups.

```{r volcanoplot, fig.cap="", results='hide', cache=TRUE}
# Second coefficient is the NL/DM comparison
stats.core <- topTable(fit2, 
                       coef=3, 
                       sort.by="B", 
                       number=length(symbols),
                       genelist=gene.annots)

# Add flags for genes that pass thresholds (significant only)
stats.core$Passes.FDR.threshold <- as.factor(stats.core$adj.P.Val < pvalcutoff)

g <- ggplot(data=stats.core, 
            aes(x=logFC, y=-log10(P.Value),
                color=Passes.FDR.threshold, size=B)) +
  geom_point(alpha=0.5) +
  geom_vline(xintercept=c(-logFCcutoff, logFCcutoff), 
             color="orange", alpha=0.7, lwd=1.25) +
  xlab("log2 fold change") + ylab("-log10 p-value") + 
  labs(title='NL vs DM')  
g
```

Not too many differences -- I had to lower the fold-change quite a bit to pick up anything at all. Almost to be expected given the PCA; variability within samples seems fairly large (or differences between conditions are small).

### Statistics and expression levels for ALL genes (in Excel files)

```{r all_exprs_stats, results='hide'}
eset.all <- exprs(geneSummaries)[stats.core$probeids, ]
colnames(eset.all) <- pData(geneSummaries)$name
eset.stats.all <- cbind(stats.core, eset.all)
write.table(eset.stats.all, 
            file=file.path(resultsDir, 
                           paste("all.stats", "xls",sep=".")), 
row.names=F, col.names=T, sep='\t')
```

[Links to Excel files with gene expression information](./results/`r paste("all.stats", "xls",sep=".")`)


### Exon-level analysis

Switching from gene summaries to exon-level summaries and retracing all other steps, including fitting the limma model:

```{r exonSummaries}
probesetSummaries <- rma(affyRaw, target='probeset', background=T, normalize=T)

# Retrieve NetAffx Biological Annotation
featureData(probesetSummaries) <- getNetAffx(probesetSummaries, "probeset")
probesetSummaries

# Remove control and unannotated probes
probesetSummaries <- probesetSummaries[which(pData(featureData(probesetSummaries))$probesettype=="main"), ]
dim(probesetSummaries) == dim(exprs(probesetSummaries))

# Extract the 'gene assignment' annotation
probeannot <- pData(featureData(probesetSummaries)[, c('geneassignment')])
probeannot <- probeannot[, 1]
head(probeannot)

# Limit to the first identifiers
probedesc <- as.data.frame(unlist(lapply(probeannot, 
                                         function(x) strsplit(x, ' // ')[[1]][2])))

# Add probeset identifiers
probedesc$probes <- rownames(exprs(probesetSummaries))
colnames(probedesc) <- c('Desc', 'Probe')
head(probedesc)

# Check to make sure data is correct
identical(length(featureData(probesetSummaries)$probesetid), nrow(probedesc)) 
identical(probedesc$Probe, rownames(exprs(probesetSummaries)))

# Experimental design
gender <- pData(probesetSummaries)$Gender
groups <- pData(probesetSummaries)$Group
design <- model.matrix(~gender+groups)
colnames(design) <- c('Intercept', 'Male', 'NL_vs_DM')                       

# Get the probe intensities and fit the model
probeSet <- exprs(probesetSummaries)
fit <- lmFit(probeSet, design)
fit2 <- eBayes(fit)
options(digits=2)

# Second coefficient is the NL/DM comparison
stats.exon <- topTable(fit2, 
                       coef=3, 
                       sort.by="B", 
                       number=30,
                       genelist=probedesc)
```

Taking a look at the top 30 results:

```{r exonResults, results='asis'}
design.gvis <- gvisTable(as.data.frame(stats.exon), options=list(width=600))  
print(design.gvis, "chart")
```

Less than ideal: as with the gene level no changes reach statistical significance. Stopping for now with the test for DE genes and exons.


[1]: http://www.bioconductor.org (BioC)
[2]: http://www.bioconductor.org/packages/2.10/bioc/html/arrayQualityMetrics.html (arrayQualityMetrics)
[3]: http://bioinformatics.oxfordjournals.org/content/19/2/185 (RMA)
[4]: http://www.bioconductor.org/packages/release/bioc/html/limma.html (limma)
[5]: http://bmbolstad.com/misc/ComputeRMAFAQ/ComputeRMAFAQ.html (RMA)
[6]: http://www.bioconductor.org/packages/release/bioc/html/sva.html (sva)
[7]: http://www.bioconductor.org/packages/release/data/annotation/html/pd.mogene.2.0.st.html
